### **1. Детальный разбор кода**

#### **1.1. Предварительные определения и глобальные переменные**

```cpp
#define NUM_LEDS 5
#define START_LED 2

const int led_periods[NUM_LEDS] = {50, 100, 150, 200, 250};
volatile int led_counters[NUM_LEDS] = {0};
```

*   `NUM_LEDS`: Количество управляемых светодиодов.
*   `START_LED`: Номер первого пина в порту `D`, к которому подключен светодиод. Это позволяет гибко менять начальный пин, не переписывая весь код.
*   `led_periods`: Массив констант, определяющих периоды мигания в единицах "тиков" прерывания таймера. Это соответствует требованию "выражаться как целое кратное минимальной единице времени".
*   `led_counters`: Массив счетчиков для каждого светодиода. Модификатор `volatile` критически важен, так как переменные изменяются внутри обработчика прерывания. Он запрещает компилятору применять оптимизации, которые могли бы привести к некорректному чтению их значений в основном цикле.

#### **1.2. Настройка аппаратной части (`setup`)**

```cpp
cli();
```
Первой командой глобальные прерывания отключаются. Это стандартная практика для безопасной настройки периферии, чтобы прерывание не возникло в момент изменения критических регистров.

```cpp
DDRD = 0b00111110;
```
**Настройка порта ввода/вывода.** Регистр `DDRD` (Data Direction Register D) определяет направление данных для каждого пина порта D. Запись `1` устанавливает пин как выход.
*   `0b00111110` в бинарном формате означает, что биты 1-5 установлены в `1`.
*   Порт D: | PD7 | PD6 | PD5 | PD4 | PD3 | PD2 | PD1 | PD0 |
*   Наша маска: |  0  |  0  |  1  |  1  |  1  |  1  |  1  |  0  |
Таким образом, пины **2, 3, 4, 5, 6** настроены как выходы.

```cpp
TCCR1A = 0;
TCCR1B = 0;
```
Сброс регистров управления таймером `Timer1`. Это гарантирует, что таймер начинает настройку с известного, нулевого состояния.

```cpp
OCR1A = 2499;
```
**Установка верхнего предела счёта.** Таймер будет считать от 0 до значения в регистре `OCR1A`, после чего сгенерирует прерывание и обнулится. Это называется **CTC (Clear Timer on Compare Match)** режим.

**Расчёт значения для `OCR1A`:**
*   Тактовая частота МК: 16 000 000 Гц.
*   Предделитель: 64. Частота счёта таймера: 16 000 000 / 64 = 250 000 Гц.
*   Желаемая частота прерываний: 100 Гц (период 10 мс).
*   `OCR1A = (Частота_таймера / Желаемая_частота_прерываний) - 1`
*   `OCR1A = (250 000 / 100) - 1 = 2500 - 1 = 2499`

```cpp
TCCR1B |= (1 << WGM12);
```
Установка бита `WGM12` в регистре `TCCR1B` активирует CTC-режим для `Timer1`.

```cpp
TCCR1B |= (1 << CS11) | (1 << CS10);
```
**Установка предделителя.** Бит `CS10` и `CS11` устанавливаются в `1`, что соответствует коэффициенту деления 64 (`0b011`). Таймер начинает свою работу.

```cpp
TIMSK1 |= (1 << OCIE1A);
```
Разрешение прерывания по совпадению с регистром `OCR1A`. Как только счетчик таймера достигает значения `2499`, генерируется прерывание `TIMER1_COMPA_vect`.

```cpp
sei();
```
Включение глобальных прерываний. С этого момента обработчик прерываний `ISR(TIMER1_COMPA_vect)` может вызываться.

#### **1.3. Обработчик прерывания (`ISR`)**

```cpp
ISR(TIMER1_COMPA_vect) {
  for (int i = START_LED; i < START_LED + NUM_LEDS; i++) {
    int led_number = i - START_LED;
    led_counters[led_number]++;

    if (led_counters[led_number] >= led_periods[led_number]) {
      PORTD ^= (1 << i);
      led_counters[led_number] = 0;
    }
  }
}
```

*   `ISR(TIMER1_COMPA_vect)`: Объявление функции-обработчика для конкретного вектора прерывания.
*   Цикл `for`: Перебираются не индексы массива, а непосредственно номера пинов микроконтроллера (от `START_LED` до `START_LED + NUM_LEDS - 1`).
*   `int led_number = i - START_LED;`: Вычисляется индекс (0-4) для массивов `led_counters` и `led_periods`, соответствующий текущему светодиоду.
*   `led_counters[led_number]++;`: Инкремент счётчика для текущего светодиода.
*   Условие `if`: Проверка, настал ли момент для переключения светодиода.
*   `PORTD ^= (1 << i);`: **Ключевая строка для управления портом.** Операция `(1 << i)` создает маску, где только `i-ый` бит установлен в `1`. Оператор `^=` (XOR) инвертирует состояние только этого бита в регистре `PORTD`, не затрагивая остальные. Это эффективная и атомарная операция "переключения" вывода.
*   `led_counters[led_number] = 0;`: Сброс счётчика для начала нового периода мигания.

### **2. Результаты и тестирование**

После прошивки данного кода в микроконтроллер и подключения светодиодов (через токоограничивающие резисторы) к пинам 2-6 порта D можно наблюдать следующее:

*   **Светодиод на пине 2:** Мигает с периодом `50 * 10 мс = 500 мс` (1 Гц).
*   **Светодиод на пине 3:** Мигает с периодом `100 * 10 мс = 1000 мс` (0.5 Гц).
*   **Светодиод на пине 4:** Период 1500 мс.
*   **Светодиод на пине 5:** Период 2000 мс.
*   **Светодиод на пине 6:** Период 2500 мс.

Все светодиоды мигают абсолютно независимо друг от друга. Основной цикл программы (`loop`) остаётся свободным для выполнения других задач, например, опроса кнопок или связи с компьютером.
